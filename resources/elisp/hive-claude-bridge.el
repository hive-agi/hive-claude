;;; hive-claude-bridge.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(declare-function vterm-mode "vterm")

(declare-function vterm-send-string "vterm")

(declare-function vterm-send-return "vterm")

(declare-function eat-mode "eat")

(declare-function eat-exec "eat")

(declare-function eat-term-send-string "eat")

(declare-function claude-code-ide--create-terminal-session "claude-code-ide")

(declare-function claude-code-ide-mcp-server-ensure-server "claude-code-ide-mcp-server")

(declare-function hive-mcp-swarm-presets-build-system-prompt "hive-mcp-swarm-presets")

(declare-function hive-claude-config-build-command "hive-claude-config")

(declare-function hive-claude-config-build-env "hive-claude-config")

(declare-function hive-claude-config-make-buffer-name "hive-claude-config")

(declare-function hive-claude-config-write-prompt-file "hive-claude-config")

(declare-function hive-claude-config-build-identity-section "hive-claude-config")

(declare-function hive-claude-state-register-session "hive-claude-state")

(declare-function hive-claude-state-remove-session "hive-claude-state")

(declare-function hive-claude-state-get-session "hive-claude-state")

(declare-function hive-claude-state-get-field "hive-claude-state")

(declare-function hive-claude-state-put-field "hive-claude-state")

(defvar hive-claude-config-buffer-prefix)

(defvar hive-claude-config-prompt-mode)

(defvar hive-claude-bridge-default-terminal 'claude-code-ide "Default terminal backend for spawning Claude lings.\n   - claude-code-ide: WebSocket MCP integration (recommended)\n   - vterm: Native terminal\n   - eat: Pure elisp (experimental)")

(defun hive-claude-bridge--ensure-terminal-available (backend)
  "Ensure the terminal BACKEND package is loaded. Signals error if unavailable."
  (pcase backend ('claude-code-ide (unless (require 'claude-code-ide nil t) (error "claude-code-ide is required but not available"))) ('vterm (unless (and (require 'vterm nil t) (fboundp 'vterm-mode) (fboundp 'vterm-send-string)) (error "vterm is required but not available"))) ('eat (unless (require 'eat nil t) (error "eat is required but not available")))))

(defun hive-claude-bridge--spawn-vterm (buffer slave-id work-dir claude-cmd)
  "Spawn Claude in a vterm BUFFER. Sends CLAUDE-CMD after vterm initializes."
  (with-current-buffer buffer
    (vterm-mode)
    (run-at-time 0.5 nil (lambda ()
    (condition-case err (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (vterm-send-string claude-cmd)
    (vterm-send-return))) (error (message "[hive-claude] vterm send error for %s: %s" slave-id (error-message-string err))))))))

(defun hive-claude-bridge--spawn-eat (buffer slave-id work-dir claude-cmd)
  "Spawn Claude in an eat BUFFER. Starts shell then sends CLAUDE-CMD."
  (with-current-buffer buffer
    (eat-mode)
    (eat-exec buffer "swarm-shell" "/bin/bash" nil '("-l")))
  (run-at-time 0.5 nil (lambda ()
    (condition-case err (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (when (and (boundp 'eat-terminal) eat-terminal)
    (eat-term-send-string eat-terminal claude-cmd)
    (eat-term-send-string eat-terminal "\r")))) (error (message "[hive-claude] eat send error for %s: %s" slave-id (error-message-string err)))))))

(defun hive-claude-bridge--spawn-claude-code-ide (buffer-name slave-id work-dir system-prompt-file)
  "Spawn Claude via claude-code-ide with WebSocket MCP integration.\n   Returns (buffer . process) cons cell."
  (let* ((port (when (fboundp 'claude-code-ide-mcp-server-ensure-server)
    (claude-code-ide-mcp-server-ensure-server))))
    (unless port (error "Failed to start MCP server for claude-code-ide backend"))
    (claude-code-ide--create-terminal-session buffer-name work-dir port nil nil slave-id system-prompt-file)))

(defun hive-claude-bridge-spawn (slave-id name opts)
  "Spawn a Claude ling in a terminal buffer.\n\n   SLAVE-ID  - Unique ling identifier (from hive-mcp DataScript)\n   NAME      - Human-readable name (for buffer naming)\n   OPTS      - Plist with:\n     :presets          - List of preset names\n     :cwd             - Working directory\n     :depth           - Spawn depth (for env var)\n     :parent-id       - Parent agent ID\n     :terminal        - Backend override (:vterm, :claude-code-ide, :eat)\n     :injected-context - Pre-generated catchup context string\n\n   Returns slave-id on success."
  (let* ((work-dir (or (plist-get opts :cwd) default-directory))
        (presets (plist-get opts :presets))
        (depth (or (plist-get opts :depth) 1))
        (parent-id (or (plist-get opts :parent-id) "master"))
        (terminal (or (plist-get opts :terminal) hive-claude-bridge-default-terminal))
        (injected-ctx (plist-get opts :injected-context))
        (buffer-name (hive-claude-config-make-buffer-name name))
        (base-prompt (when (fboundp 'hive-mcp-swarm-presets-build-system-prompt)
    (condition-case _err (hive-mcp-swarm-presets-build-system-prompt presets injected-ctx) (error nil))))
        (identity (hive-claude-config-build-identity-section slave-id work-dir))
        (system-prompt (if base-prompt (format "%s%s" identity base-prompt) identity))
        (prompt-file (hive-claude-config-write-prompt-file system-prompt)))
    (hive-claude-state-register-session slave-id (list :slave-id slave-id :name name :cwd work-dir :presets presets :terminal terminal :depth depth :parent-id parent-id :status 'spawning :buffer nil :spawned-at (format-time-string "%FT%T%z")))
    (hive-claude-bridge--ensure-terminal-available terminal)
    (let* ((env-additions (hive-claude-config-build-env slave-id depth parent-id))
        (claude-cmd (hive-claude-config-build-command work-dir prompt-file))
        (default-directory work-dir)
        (process-environment (append env-additions process-environment)))
    (pcase terminal ('claude-code-ide (let* ((result (hive-claude-bridge--spawn-claude-code-ide buffer-name slave-id work-dir prompt-file)))
    (hive-claude-state-put-field slave-id :buffer (car result))
    (hive-claude-state-put-field slave-id :process (cdr result)))) ('vterm (let* ((buffer (generate-new-buffer buffer-name)))
    (hive-claude-state-put-field slave-id :buffer buffer)
    (hive-claude-bridge--spawn-vterm buffer slave-id work-dir claude-cmd))) ('eat (let* ((buffer (generate-new-buffer buffer-name)))
    (hive-claude-state-put-field slave-id :buffer buffer)
    (hive-claude-bridge--spawn-eat buffer slave-id work-dir claude-cmd)))))
    (run-at-time 3 nil (lambda ()
    (condition-case _err (let* ((session (hive-claude-state-get-session slave-id)))
    (when (and session (memq (plist-get session :status) '(starting spawning)))
    (hive-claude-state-put-field slave-id :status 'idle))) (error nil))))
    (hive-claude-state-put-field slave-id :status 'starting)
    (message "[hive-claude] Spawned %s via %s" slave-id terminal)
    slave-id))

(defun hive-claude-bridge-dispatch (slave-id prompt)
  "Send PROMPT to a running Claude ling identified by SLAVE-ID.\n   Returns (:sent t :slave-id SLAVE-ID) on success."
  (let* ((buffer (hive-claude-state-get-field slave-id :buffer))
        (terminal (or (hive-claude-state-get-field slave-id :terminal) hive-claude-bridge-default-terminal)))
    (when (and buffer (buffer-live-p buffer))
    (pcase terminal ('claude-code-ide (with-current-buffer buffer
    (when (fboundp 'claude-code-ide--terminal-send-string)
    (claude-code-ide--terminal-send-string prompt)
    (claude-code-ide--terminal-send-return)))) ('vterm (with-current-buffer buffer
    (vterm-send-string prompt)
    (vterm-send-return))) ('eat (with-current-buffer buffer
    (when (and (boundp 'eat-terminal) eat-terminal)
    (eat-term-send-string eat-terminal prompt)
    (eat-term-send-string eat-terminal "\r")))))
    (hive-claude-state-put-field slave-id :status 'working)
    (list :sent t :slave-id slave-id))))

(defun hive-claude-bridge--valid-kill-target-p (buffer slave-id)
  "Validate BUFFER is safe to kill for SLAVE-ID.\n   Returns t if safe, nil if killing would be dangerous."
  (when (buffer-live-p buffer)
    (let* ((buf-name (buffer-name buffer))
        (buf-name-lower (downcase buf-name)))
    (and (string-prefix-p hive-claude-config-buffer-prefix buf-name) (not (string-match-p "coordinator" buf-name-lower)) (not (string-match-p "\\*claude-code" buf-name-lower)) (not (string-match-p "\\*claude code" buf-name-lower)) (not (string-match-p "master" buf-name-lower))))))

(defun hive-claude-bridge-kill (slave-id)
  "Kill the Claude ling SLAVE-ID. Returns t on success, nil if blocked."
  (let* ((session (hive-claude-state-get-session slave-id)))
    (if (not session) (progn (message "[hive-claude] Slave not found: %s" slave-id) nil) (let* ((buffer (plist-get session :buffer)))
    (if (null buffer) (progn (hive-claude-state-remove-session slave-id) t) (if (not (buffer-live-p buffer)) (progn (hive-claude-state-remove-session slave-id) t) (if (not (hive-claude-bridge--valid-kill-target-p buffer slave-id)) (progn (message "[hive-claude] BLOCKED: safety validation failed for %s" slave-id) (hive-claude-state-remove-session slave-id) nil) (progn (with-current-buffer buffer
    (set-buffer-modified-p nil)
    (let* ((temp__5823__auto__ (get-buffer-process buffer)))
    (when temp__5823__auto__ (progn
  (let* ((proc temp__5823__auto__))
    (set-process-query-on-exit-flag proc nil)))))
    (when (and (boundp 'vterm--process) vterm--process (process-live-p vterm--process))
    (set-process-query-on-exit-flag vterm--process nil))) (let* ((kill-buffer-query-functions nil)
        (kill-buffer-hook nil)
        (vterm-exit-functions nil))
    (kill-buffer buffer)) (hive-claude-state-remove-session slave-id) (message "[hive-claude] Killed %s" slave-id) t))))))))

(defun hive-claude-bridge-status (slave-id)
  "Return status plist for SLAVE-ID."
  (let* ((session (hive-claude-state-get-session slave-id)))
    (when session
    (let* ((buffer (plist-get session :buffer))
        (alive (and buffer (buffer-live-p buffer))))
    (list :slave-id slave-id :name (plist-get session :name) :status (if alive (plist-get session :status) 'dead) :cwd (plist-get session :cwd) :terminal (plist-get session :terminal) :buffer-alive alive)))))

(defun hive-claude-bridge-interrupt (slave-id)
  "Send Ctrl-C to interrupt the running Claude ling SLAVE-ID."
  (let* ((buffer (hive-claude-state-get-field slave-id :buffer))
        (terminal (or (hive-claude-state-get-field slave-id :terminal) hive-claude-bridge-default-terminal)))
    (when (and buffer (buffer-live-p buffer))
    (with-current-buffer buffer
    (pcase terminal ('vterm (vterm-send-key "c" nil nil t)) ('eat (when (and (boundp 'eat-terminal) eat-terminal)
    (eat-term-send-string eat-terminal "\\C-c"))) ('claude-code-ide (when (fboundp 'claude-code-ide--terminal-send-string)
    (vterm-send-key "c" nil nil t)))))
    (hive-claude-state-put-field slave-id :status 'idle)
    (list :interrupted t :slave-id slave-id))))

(defun hive-claude-bridge-api-spawn (slave-id name presets cwd depth parent-id context-file)
  "API entry point for hive-mcp ITerminalAddon.terminal-spawn!\n\n   Called via (eval-elisp (format \"(hive-claude-bridge-api-spawn ...)\")).\n   CONTEXT-FILE is a path to pre-generated catchup context (read + deleted)."
  (let* ((injected-ctx (when (and context-file (stringp context-file) (file-exists-p context-file))
    (prog1 (with-temp-buffer
    (insert-file-contents context-file)
    (buffer-string)) (ignore-errors (delete-file context-file))))))
    (hive-claude-bridge-spawn slave-id name (list :presets (when (and presets (not (eq presets 'nil)))
    presets) :cwd (when (stringp cwd)
    cwd) :depth (or depth 1) :parent-id (when (stringp parent-id)
    parent-id) :injected-context injected-ctx))))

(defun hive-claude-bridge-api-dispatch (slave-id prompt)
  "API entry point for hive-mcp ITerminalAddon.terminal-dispatch!"
  (hive-claude-bridge-dispatch slave-id prompt))

(defun hive-claude-bridge-api-kill (slave-id)
  "API entry point for hive-mcp ITerminalAddon.terminal-kill!"
  (if (hive-claude-bridge-kill slave-id) (list :killed t :slave-id slave-id) (list :error "kill-blocked" :slave-id slave-id)))

(defun hive-claude-bridge-api-status (slave-id)
  "API entry point for hive-mcp ITerminalAddon.terminal-status."
  (hive-claude-bridge-status slave-id))

(defun hive-claude-bridge-api-interrupt (slave-id)
  "API entry point for hive-mcp ITerminalAddon.terminal-interrupt!"
  (hive-claude-bridge-interrupt slave-id))

(provide 'hive-claude-bridge)
;;; hive-claude-bridge.el ends here
