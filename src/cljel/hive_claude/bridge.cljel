(ns hive-claude.bridge
  "Core bridge: spawn/kill/dispatch/status for Claude Code lings in Emacs terminals.

   This is the main entry point, called from hive-mcp's JVM-side ITerminalAddon
   implementation via elisp eval. It delegates to config for command building,
   state for session tracking, and the terminal backend (vterm or claude-code-ide)
   for actual buffer management.

   Terminal backend dispatch:
   - claude-code-ide (default): Full WebSocket MCP integration
   - vterm: Native terminal, reliable input
   - eat: Pure elisp terminal (experimental)

   Extracted from hive-mcp-swarm-slaves.el to be a standalone, composable module.")

;; ============================================================================
;; Dependencies (soft — checked at spawn time)
;; ============================================================================

;; vterm
(declare-function vterm-mode "vterm")
(declare-function vterm-send-string "vterm")
(declare-function vterm-send-return "vterm")

;; eat
(declare-function eat-mode "eat")
(declare-function eat-exec "eat")
(declare-function eat-term-send-string "eat")

;; claude-code-ide
(declare-function claude-code-ide--create-terminal-session "claude-code-ide")
(declare-function claude-code-ide-mcp-server-ensure-server "claude-code-ide-mcp-server")

;; hive-mcp-swarm (preset building — optional integration)
(declare-function hive-mcp-swarm-presets-build-system-prompt "hive-mcp-swarm-presets")

;; hive-claude sibling modules
(declare-function hive-claude-config-build-command "hive-claude-config")
(declare-function hive-claude-config-build-env "hive-claude-config")
(declare-function hive-claude-config-make-buffer-name "hive-claude-config")
(declare-function hive-claude-config-write-prompt-file "hive-claude-config")
(declare-function hive-claude-config-build-identity-section "hive-claude-config")
(declare-function hive-claude-state-register-session "hive-claude-state")
(declare-function hive-claude-state-remove-session "hive-claude-state")
(declare-function hive-claude-state-get-session "hive-claude-state")
(declare-function hive-claude-state-get-field "hive-claude-state")
(declare-function hive-claude-state-put-field "hive-claude-state")

;; Config variables
(defvar hive-claude-config-buffer-prefix)
(defvar hive-claude-config-prompt-mode)

;; ============================================================================
;; Customizable
;; ============================================================================

(defvar default-terminal 'claude-code-ide
  "Default terminal backend for spawning Claude lings.
   - claude-code-ide: WebSocket MCP integration (recommended)
   - vterm: Native terminal
   - eat: Pure elisp (experimental)")

;; ============================================================================
;; Terminal Requirement Check
;; ============================================================================

(defn- ensure-terminal-available [backend]
  "Ensure the terminal BACKEND package is loaded. Signals error if unavailable."
  (pcase backend
    ('claude-code-ide
     (unless (require 'claude-code-ide nil t)
       (error "claude-code-ide is required but not available")))
    ('vterm
     (unless (and (require 'vterm nil t)
                  (fboundp 'vterm-mode)
                  (fboundp 'vterm-send-string))
       (error "vterm is required but not available")))
    ('eat
     (unless (require 'eat nil t)
       (error "eat is required but not available")))))

;; ============================================================================
;; Spawn
;; ============================================================================

(defn- spawn-vterm [buffer slave-id work-dir claude-cmd]
  "Spawn Claude in a vterm BUFFER. Sends CLAUDE-CMD after vterm initializes."
  (with-current-buffer buffer
    (vterm-mode)
    (run-at-time 0.5 nil
      (lambda (_unused)
        (condition-case err
          (when (buffer-live-p buffer)
            (with-current-buffer buffer
              (vterm-send-string claude-cmd)
              (vterm-send-return)))
          (error
           (message "[hive-claude] vterm send error for %s: %s"
                    slave-id (error-message-string err))))))))

(defn- spawn-eat [buffer slave-id work-dir claude-cmd]
  "Spawn Claude in an eat BUFFER. Starts shell then sends CLAUDE-CMD."
  (with-current-buffer buffer
    (eat-mode)
    (eat-exec buffer "swarm-shell" "/bin/bash" nil '("-l")))
  (run-at-time 0.5 nil
    (lambda (_unused)
      (condition-case err
        (when (buffer-live-p buffer)
          (with-current-buffer buffer
            (when (and (boundp 'eat-terminal) eat-terminal)
              (eat-term-send-string eat-terminal claude-cmd)
              (eat-term-send-string eat-terminal "\r"))))
        (error
         (message "[hive-claude] eat send error for %s: %s"
                  slave-id (error-message-string err)))))))

(defn- spawn-claude-code-ide [buffer-name slave-id work-dir system-prompt-file]
  "Spawn Claude via claude-code-ide with WebSocket MCP integration.
   Returns (buffer . process) cons cell."
  (let [port (when (fboundp 'claude-code-ide-mcp-server-ensure-server)
               (claude-code-ide-mcp-server-ensure-server))]
    (unless port
      (error "Failed to start MCP server for claude-code-ide backend"))
    (claude-code-ide--create-terminal-session
     buffer-name work-dir port
     nil    ;; continue
     nil    ;; resume
     slave-id
     system-prompt-file)))

(defn spawn [slave-id name opts]
  "Spawn a Claude ling in a terminal buffer.

   SLAVE-ID  - Unique ling identifier (from hive-mcp DataScript)
   NAME      - Human-readable name (for buffer naming)
   OPTS      - Plist with:
     :presets          - List of preset names
     :cwd             - Working directory
     :depth           - Spawn depth (for env var)
     :parent-id       - Parent agent ID
     :terminal        - Backend override (:vterm, :claude-code-ide, :eat)
     :injected-context - Pre-generated catchup context string

   Returns slave-id on success."
  (let [work-dir (or (plist-get opts :cwd) default-directory)
        presets (plist-get opts :presets)
        depth (or (plist-get opts :depth) 1)
        parent-id (or (plist-get opts :parent-id) "master")
        terminal (or (plist-get opts :terminal) hive-claude-bridge-default-terminal)
        injected-ctx (plist-get opts :injected-context)
        buffer-name (hive-claude-config-make-buffer-name name)
        ;; Build system prompt
        base-prompt (when (fboundp 'hive-mcp-swarm-presets-build-system-prompt)
                      (condition-case _err
                        (hive-mcp-swarm-presets-build-system-prompt presets injected-ctx)
                        (error nil)))
        identity (hive-claude-config-build-identity-section slave-id work-dir)
        system-prompt (if base-prompt
                        (format "%s%s" identity base-prompt)
                        identity)
        prompt-file (hive-claude-config-write-prompt-file system-prompt)]

    ;; Register session state
    (hive-claude-state-register-session slave-id
      (list :slave-id slave-id
            :name name
            :cwd work-dir
            :presets presets
            :terminal terminal
            :depth depth
            :parent-id parent-id
            :status 'spawning
            :buffer nil
            :spawned-at (format-time-string "%FT%T%z")))

    ;; Ensure terminal backend is available
    (hive-claude-bridge--ensure-terminal-available terminal)

    ;; Build env and command
    (let [env-additions (hive-claude-config-build-env slave-id depth parent-id)
          claude-cmd (hive-claude-config-build-command work-dir prompt-file)
          default-directory work-dir
          process-environment (append env-additions process-environment)]

      (pcase terminal
        ('claude-code-ide
         (let [result (hive-claude-bridge--spawn-claude-code-ide
                        buffer-name slave-id work-dir prompt-file)]
           (hive-claude-state-put-field slave-id :buffer (car result))
           (hive-claude-state-put-field slave-id :process (cdr result))))

        ('vterm
         (let [buffer (generate-new-buffer buffer-name)]
           (hive-claude-state-put-field slave-id :buffer buffer)
           (hive-claude-bridge--spawn-vterm buffer slave-id work-dir claude-cmd)))

        ('eat
         (let [buffer (generate-new-buffer buffer-name)]
           (hive-claude-state-put-field slave-id :buffer buffer)
           (hive-claude-bridge--spawn-eat buffer slave-id work-dir claude-cmd)))))

    ;; Schedule transition to idle
    (run-at-time 3 nil
      (lambda (_unused)
        (condition-case _err
          (let [session (hive-claude-state-get-session slave-id)]
            (when (and session (memq (plist-get session :status) '(starting spawning)))
              (hive-claude-state-put-field slave-id :status 'idle)))
          (error nil))))

    (hive-claude-state-put-field slave-id :status 'starting)
    (message "[hive-claude] Spawned %s via %s" slave-id terminal)
    slave-id))

;; ============================================================================
;; Dispatch
;; ============================================================================

(defn dispatch [slave-id prompt]
  "Send PROMPT to a running Claude ling identified by SLAVE-ID.
   Returns (:sent t :slave-id SLAVE-ID) on success."
  (let [buffer (hive-claude-state-get-field slave-id :buffer)
        terminal (or (hive-claude-state-get-field slave-id :terminal)
                     hive-claude-bridge-default-terminal)]
    (when (and buffer (buffer-live-p buffer))
      (pcase terminal
        ('claude-code-ide
         ;; claude-code-ide uses its own send mechanism
         (with-current-buffer buffer
           (when (fboundp 'claude-code-ide--terminal-send-string)
             (claude-code-ide--terminal-send-string prompt)
             (claude-code-ide--terminal-send-return))))
        ('vterm
         (with-current-buffer buffer
           (vterm-send-string prompt)
           (vterm-send-return)))
        ('eat
         (with-current-buffer buffer
           (when (and (boundp 'eat-terminal) eat-terminal)
             (eat-term-send-string eat-terminal prompt)
             (eat-term-send-string eat-terminal "\r")))))
      (hive-claude-state-put-field slave-id :status 'working)
      (list :sent t :slave-id slave-id))))

;; ============================================================================
;; Kill
;; ============================================================================

(defn- valid-kill-target? [buffer slave-id]
  "Validate BUFFER is safe to kill for SLAVE-ID.
   Returns t if safe, nil if killing would be dangerous."
  (when (buffer-live-p buffer)
    (let [buf-name (buffer-name buffer)
          buf-name-lower (downcase buf-name)]
      (and
       ;; Must have swarm prefix
       (string-prefix-p hive-claude-config-buffer-prefix buf-name)
       ;; Must NOT contain coordinator patterns
       (not (string-match-p "coordinator" buf-name-lower))
       (not (string-match-p "\\*claude-code" buf-name-lower))
       (not (string-match-p "\\*claude code" buf-name-lower))
       (not (string-match-p "master" buf-name-lower))))))

(defn kill [slave-id]
  "Kill the Claude ling SLAVE-ID. Returns t on success, nil if blocked."
  (let [session (hive-claude-state-get-session slave-id)]
    (if (not session)
      (progn (message "[hive-claude] Slave not found: %s" slave-id) nil)
      (let [buffer (plist-get session :buffer)]
        (if (null buffer)
          ;; No buffer — just clean up state
          (progn (hive-claude-state-remove-session slave-id) t)
          (if (not (buffer-live-p buffer))
            ;; Buffer already dead
            (progn (hive-claude-state-remove-session slave-id) t)
            (if (not (hive-claude-bridge--valid-kill-target? buffer slave-id))
              ;; Safety check failed
              (progn
                (message "[hive-claude] BLOCKED: safety validation failed for %s" slave-id)
                (hive-claude-state-remove-session slave-id)
                nil)
              ;; Proceed with kill
              (progn
                (with-current-buffer buffer
                  (set-buffer-modified-p nil)
                  (when-let [proc (get-buffer-process buffer)]
                    (set-process-query-on-exit-flag proc nil))
                  (when (and (boundp 'vterm--process) vterm--process
                             (process-live-p vterm--process))
                    (set-process-query-on-exit-flag vterm--process nil)))
                (let [kill-buffer-query-functions nil
                      kill-buffer-hook nil
                      vterm-exit-functions nil]
                  (kill-buffer buffer))
                (hive-claude-state-remove-session slave-id)
                (message "[hive-claude] Killed %s" slave-id)
                t))))))))


;; ============================================================================
;; Status
;; ============================================================================

(defn status [slave-id]
  "Return status plist for SLAVE-ID."
  (let [session (hive-claude-state-get-session slave-id)]
    (when session
      (let [buffer (plist-get session :buffer)
            alive (and buffer (buffer-live-p buffer))]
        (list :slave-id slave-id
              :name (plist-get session :name)
              :status (if alive
                        (plist-get session :status)
                        'dead)
              :cwd (plist-get session :cwd)
              :terminal (plist-get session :terminal)
              :buffer-alive alive)))))

;; ============================================================================
;; Interrupt
;; ============================================================================

(defn interrupt [slave-id]
  "Send Ctrl-C to interrupt the running Claude ling SLAVE-ID."
  (let [buffer (hive-claude-state-get-field slave-id :buffer)
        terminal (or (hive-claude-state-get-field slave-id :terminal)
                     hive-claude-bridge-default-terminal)]
    (when (and buffer (buffer-live-p buffer))
      (with-current-buffer buffer
        (pcase terminal
          ('vterm (vterm-send-key "c" nil nil t))
          ('eat (when (and (boundp 'eat-terminal) eat-terminal)
                  (eat-term-send-string eat-terminal "\C-c")))
          ('claude-code-ide
           (when (fboundp 'claude-code-ide--terminal-send-string)
             ;; claude-code-ide handles interrupt via its own mechanism
             (vterm-send-key "c" nil nil t)))))
      (hive-claude-state-put-field slave-id :status 'idle)
      (list :interrupted t :slave-id slave-id))))

;; ============================================================================
;; API Entry Points (for hive-mcp JVM-side eval-elisp calls)
;; ============================================================================

(defn api-spawn [slave-id name presets cwd depth parent-id context-file]
  "API entry point for hive-mcp ITerminalAddon.terminal-spawn!

   Called via (eval-elisp (format \"(hive-claude-bridge-api-spawn ...)\")).
   CONTEXT-FILE is a path to pre-generated catchup context (read + deleted)."
  (let [injected-ctx (when (and context-file (stringp context-file)
                                (file-exists-p context-file))
                       (prog1
                         (with-temp-buffer
                           (insert-file-contents context-file)
                           (buffer-string))
                         (ignore-errors (delete-file context-file))))]
    (hive-claude-bridge-spawn slave-id name
      (list :presets (when (and presets (not (eq presets 'nil))) presets)
            :cwd (when (stringp cwd) cwd)
            :depth (or depth 1)
            :parent-id (when (stringp parent-id) parent-id)
            :injected-context injected-ctx))))

(defn api-dispatch [slave-id prompt]
  "API entry point for hive-mcp ITerminalAddon.terminal-dispatch!"
  (hive-claude-bridge-dispatch slave-id prompt))

(defn api-kill [slave-id]
  "API entry point for hive-mcp ITerminalAddon.terminal-kill!"
  (if (hive-claude-bridge-kill slave-id)
    (list :killed t :slave-id slave-id)
    (list :error "kill-blocked" :slave-id slave-id)))

(defn api-status [slave-id]
  "API entry point for hive-mcp ITerminalAddon.terminal-status."
  (hive-claude-bridge-status slave-id))

(defn api-interrupt [slave-id]
  "API entry point for hive-mcp ITerminalAddon.terminal-interrupt!"
  (hive-claude-bridge-interrupt slave-id))
